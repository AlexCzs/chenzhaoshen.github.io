# UITableView的优化

```
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
```

这个代理方法的实现，在可见的页面是会重复绘制页面的，所以绝大部分人都会在这里做一些代码处理
比如：

```
static NSString *CellIdentifier = @"CellID";
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
```

以上举例代码是可以让cell被重复使用，一般大概只会在可见页面部分的几个cell会被new下，其他的全部重复使用前面已经有的cell对象，到时候只要填充数据就可以了

那么仅仅只是如此，恐怕现在的cell自定义的页面不只是文本那么简单，多多少少都会带有一些图片吧，当你下滑时候是否发现有那么一点点的卡顿现成，特别是网络不好，而且还是在iPhone4上跑的就会更明显了

那么在cell里面异步加载图片是个程序员都会想到，但是如果你给每个循环对象都加上异步加载，并且下滑的时候，这一操作将会被执行，虽然是异步，但是一个app里面的线程过多也会卡顿的，特别是在下滑操作的时候给每个图片进行异步加载

那么这里可以利用UIScrollViewDelegate代理很好的解决这问题:

```
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView
```

可以识别tableview禁止或者减速滑动结束的时候进行异步加载图片

以下方法来执行异步加载操作

```
//获取可见部分的对象
 NSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];
  for (NSIndexPath *indexPath in visiblePaths)
  {
     //获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载
       <code>
  }
```

同时在cell绘制中也做限制

```
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
		if (self.tableView.dragging == NO && self.tableView.decelerating == NO)
            {
               //开始异步加载图片
                <code>
            }
```

如果tableview 停止滑动的时候开始异步加载图片

最后也别忘记在内存紧张的情况下释放调所有的异步线程，以保证的你的app不会被系统强制关闭

```
- (void)didReceiveMemoryWarning{
//  释放调异步加载图片的线程以及所有图片资源对象
<code>
}
```

还有千万别忘记销毁的时候手动把所有的使用到的代理设置nil
至此性能优化结束，来源于官方文案